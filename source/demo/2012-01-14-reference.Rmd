<!---
title: Chunk Reference/Macro
subtitle: How to reuse chunks
date: '2012-01-14'
slug: reference
--->

# チャンク参照/マクロ {-#reference}

チャンクの再利用方法

オリジナルのページ: https://yihui.org/knitr/demo/reference/

オリジナルの更新日 2012/01/14

----

```{block2, demo-reference-translateor, type="rmdtip"}
**訳注**: このページは全編を通して Sweave の構文で書かれていますが, R Markdown のチャンクでも同様のことが可能です.
```

Sweave には `<<chunk-label>>` (`<<>>=` と違い `=` がない点に注意) という構文でチャンクを再利用するためにチャンクを参照する機能があります. たとえば

``` 
<<chunk1>>=
1 + 1
@

<<chunk2>>=
<<chunk1>>
@
```

`chunk2` では `chunk1` のコードが挿入されます. この機能は **`knitr`** でも有効ですが **`knitr`** はさらに任意の (制限なし) 階層での再帰的なチャンク参照をサポートしています (Sweave は1段階までしかサポートしていませんでした). つまりあるチャンクはさらに別のチャンクを参照しているチャンクを参照できるということです.

この `<<chunk-label>>` 構文と同様のものは markdown の構文でも機能します. それ以前の, 他のチャンクを含んでいる, 名前を付けた markdown チャンクを再利用することができます. あなたの使っている R Markdown エディタが「予期しないトークンです」と構文に警告していたとしてもです.

**訳注**:  R Markdown でもチャンク中に `<<`, `>>` で囲んでラベルを書くことでチャンク参照ができます.

**knitr** でチャンクを再利用するアプローチは他にもあります.

1. 再利用したいチャンクと同じ名前のラベルを使う
1. そのチャンクを参照する `ref.label` オプションを使う

## 同じラベルを使用する {-}

1番目のアプローチの例です

```sweave
<<chunk1, echo=TRUE, results='hide'>>=
1 + 1
@

<<chunk1, echo=FALSE, results='markup'>>=
@
```

2番目のチャンクは空なので, **`knitr`** は同じ名前を持ち, 空でないチャンクを探し, そのチャンクのコードを使用します. ポイントは他のチャンクを使用するためにはチャンクの中身を空にしておくことです. 問題は, この2つのチャンクの MD5 ハッシュ値が異なるため, 両方のキャッシュを残すことができないというものです. **`knitr`** はラベル1つにつき1まとまりのキャッシュしか取ることができません.

## チャンクオプション `ref.label` {-}

2番目のアプローチの例です.

```sweave
<<chunk1, echo=TRUE, results='hide'>>=
1 + 1
@

<<chunk2, ref.label='chunk1', echo=FALSE, results='markup'>>=
@
```

2番目のチャンクはラベルが異なるので, キャッシュが取れない問題はなくなりました. 明らかに, 第2のアプローチはより汎用的な解決法です.

この機能は出力文書において R のコードと出力を分離することを可能とします. 簡単な例として, 論文を書く際に本文中に R コードを表示しないために `echo=FALSE` を設定することができます. そして補遺 (Appendix)  のセクションでこの R コードを掲載するため, チャンク参照を使います (`eval=FALSE, ref.label=...` オプションを使います).
